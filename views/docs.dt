extends layout

block title
	- title = "Documentation";

block vibed.navigation
	ul.bs-local
		li
			a(href="api/") API Reference
		li.bs-separator
			a(href="#first-steps") First steps
		li
			a(href="#examples") Example projects
		li
			a(href="#http") HTTP
			ul
				li: a(href="#http-server-config") Server configuration
				li: a(href="#http-https") HTTPS
				li: a(href="#http-routing") Routing
				li: a(href="#html-templates") Templates
				li: a(href="#http-error-pages") Error pages
				li: a(href="#http-authentication") Authentication
				li: a(href="#http-sessions") Sessions
				li: a(href="#http-client-requests") Client requests
		li
			a(href="#web") Web framework
			ul
				li: a(href="#web-interface-generator") Web interface generator
				li: a(href="#web-localization") Localization
				li: a(href="#rest-interface-generator") REST interface generator
		li
			a(href="#db-support") Database support
			ul
				li: a(href="#mongo") MongoDB
				li: a(href="#redis") Redis
		li
			a(href="#raw-tcp") Raw TCP
			ul
				li: a(href="#tcp-server") Server
				li: a(href="#tcp-client") Client
		li
			a(href="#raw-udp") Raw UDP
		li
			a(href="#advanced") Advanced topics
			ul
				li: a(href="#dub-publishing") Publishing on the DUB registry
				li: a(href="#custom-main") The main function
				li: a(href="#privilege-lowering") Privilege lowering
				li: a(href="#compile-time-configuration") Compile time configuration
				li: a(href="#handling-segmentation-faults") Handling segmentation faults on Linux
		li.bs-separator: a(href="templates/diet") Diet Reference
		li.bs-separator: a.extern(href="https://dlang.org/phobos/index.html", target="_blank") D Library Reference

block vibed.body
	section
		h2#first-steps First steps

		p First, install the <a href="https://github.com/dlang/dub">DUB package manager</a> to let it handle downloading and building of vibe.d and derived applications. On non-Windows systems, a number of additional dependencies needs to be installed. See the <a href="https://github.com/vibe-d/vibe.d#installation">project description on GitHub</a> for details.

		p Manual building (e.g. using RDMD) is a possible alternative, but you have to make sure that external libraries are linked in (such as OpenSSL). Take a look at <a href="https://github.com/vibe-d/vibe.d/blob/master/dub.sdl">vibe.d's dub.sdl</a> to determine how to build on a certain platform, or, alterntaively, run DUB with the <code>-v</code> switch to see the actual compiler command line.

		p The easiest way to get started is to run the following command from your projects directory:

		pre.code.
			cd /path/to/my/projects
			dub init &lt;project-name&gt; -t vibe.d

		p This will create a new directory with the given name and creates the basic directory structure that is recommended for vibe.d projects. Running it will start up an HTTP server on port 8080, serving a simple plain-text page. As the next step, you can go ahead and edit the <code>source/app.d</code> file. If you want to publish your project, you should also edit the <code>dub.json</code>/<code>dub.sdl</code> file and properly fill in all fields, including a "license" field.

		p Once you have the project in place, simply run DUB from the project's root directory and it will get all dependencies, compile the application, and run it:
		pre.code.
			cd path/to/project
			dub
			<span class="com">Performing "debug" build using dmd for x86_64.
			Performing "debug" build using ldc2 for x86_64.
			taggedalgebraic 0.11.8: target for configuration "library" is up to date.
			eventcore 0.8.48: target for configuration "winapi" is up to date.
			stdx-allocator 2.77.5: target for configuration "library" is up to date.
			vibe-core 1.8.0: target for configuration "winapi" is up to date.
			vibe-d:utils 0.8.6: target for configuration "library" is up to date.
			vibe-d:data 0.8.6: target for configuration "library" is up to date.
			mir-linux-kernel 1.0.1: target for configuration "library" is up to date.
			vibe-d:crypto 0.8.6: target for configuration "library" is up to date.
			diet-ng 1.6.0+commit.10.g6032ae1: target for configuration "library" is up to date.
			vibe-d:stream 0.8.6: target for configuration "library" is up to date.
			vibe-d:textfilter 0.8.6: target for configuration "library" is up to date.
			vibe-d:inet 0.8.6: target for configuration "library" is up to date.
			vibe-d:tls 0.8.6: target for configuration "openssl-mscoff" is up to date.
			vibe-d:http 0.8.6: target for configuration "library" is up to date.
			vibe-d:mail 0.8.6: target for configuration "library" is up to date.
			vibe-d:mongodb 0.8.6: target for configuration "library" is up to date.
			vibe-d:redis 0.8.6: target for configuration "library" is up to date.
			vibe-d:web 0.8.6: target for configuration "library" is up to date.
			vibe-d 0.8.6: target for configuration "vibe-core" is up to date.
			vibe-test ~master: building configuration "application"...
			Linking...
			To force a rebuild of up-to-date targets, run again with --force.
			Copying files for vibe-d:tls...
			Running .\vibe-test.exe
			[main(----) INF] Listening for requests on http://[::1]:8080/
			[main(----) INF] Listening for requests on http://127.0.0.1:8080/
			[main(----) INF] Please open http://127.0.0.1:8080/ in your browser.</span>
		h3 Recommended project structure

		p The recommended directory structure for a project, which the "dub init" command establishes, is separated into three base folders:

		pre.code.
			appname/
				source/
					app.d
				public/
					images/
					styles/
						style.css
				views/
					layout.dt
					index.dt
				dub.json
		.caption Example structure of a web application project

		p For a simple web application, the 'app.d' file could look similar to this one:

		pre.code.prettyprint.lang-d.
			import vibe.vibe;

			void index(<a href="api/vibe.http.server/HTTPServerRequest">HTTPServerRequest</a> req, <a href="api/vibe.http.server/HTTPServerResponse">HTTPServerResponse</a> res)
			{
				res.<a href="api/vibe.http.server/render">render</a>!("index.dt", req);
			}

			void main()
			{
				auto router = new <a href="api/vibe.http.router/URLRouter">URLRouter</a>;
				router.get("/", &amp;index);

				auto settings = new <a href="api/vibe.http.server/HTTPServerSettings">HTTPServerSettings</a>;
				settings.port = 8080;

				<a href="api/vibe.http.server/listenHTTP">listenHTTP</a>(settings, router);

				<a href="api/vibe.core.core/runApplication">runApplication</a>();
			}
		.caption Simple app.d file with minimal routing

		p The 'views' sub folder is automatically searched for templates instantiated with <a href="api/vibe.http.server/render"><code class="prettyprint">render</code></a>. The two templates in the example structure might look like this:

		pre.code.lang-diet.
			doctype html
			html
				head
					title Example page
				body
					block body
		.caption Example layout.dt

		pre.code.lang-diet.
			extends layout

			block body
				h1 Example page - Home
				p Hello, World!
		.caption Example index.dt

		p This structure makes use of the blocks/extensions feature of the <a href="#html-templates">Diet template</a> compiler. For more advanced template features see the <a href="templates/diet">Diet template documentation</a>.

		p Finally, the "dub.sdl" (<a target="_blank" class="extern" href="https://sdlang.org/">SDLang</a>) lets the vibe.d package manager automatically download and compile dependency libraries. This file will also provide the description that is needed to later put your own library into the <a href="https://code.dlang.org/">public extension registry</a>.

		pre.code.prettyprint.lang-javascript.
			name "appname"
			description "My fabulous new app"
			copyright "Copyright (C) 2000 Me. All rights reserved."
			license "AGPL-3.0"
			homepage "http://appname.org"
			authors "Hans Wurst"
			dependency "vibe-d" version="~&gt;0.8.6"
		.caption Example dub.sdl

		p DUB also provides support for the original JSON based syntax. The filename to use is "dub.json" in this case:
		pre.code.prettyprint.lang-javascript.
			{
				"name": "appname",
				"description": "My fabulous new app",
				"copyright": "Copyright (C) 2000 Me. All rights reserved.",
				"license": "AGPL-3.0",
				"homepage": "http://appname.org",
				"authors": ["Hans Wurst"],
				"dependencies": {
					"vibe-d": "~&gt;0.8.6"
				}
			}
		.caption Example dub.json

	section
		h2#examples Example projects

		p A library of example projects is maintained in the Git repository. Most things not covered in this document can be found there in the form of code: #[a.extern(href="https://github.com/vibe-d/vibe.d/tree/master/examples", target="_blank") Example projects]

		p To run the examples locally, you can either download the <a href="https://github.com/vibe-d/vibe.d/archive/master.zip">repository as a zip file</a>, or use GIT to get the examples:

		pre.
			git clone https://github.com/vibe-d/vibe.d.git

		p To run the "http_server" example, type:

		pre.
			dub run --root=vibe.d/examples/http_server


	section
		h2#http HTTP

		section
			h3#http-server-config Server configuration

			p The HTTP server supports a number of configuration options to customize its behavior. By default, the server will listen on all local network adapters on port 80 and will perform complete request parsing. The following list gives an overview of the most common settings:

			dl.feat
				dt: a(href="api/vibe.http.server/HTTPServerSettings.port"): code.prettyprint port
				dd The port on which the HTTP server shall listen

				dt: a(href="api/vibe.http.server/HTTPServerSettings.bindAddresses"): code.prettyprint bindAddresses
				dd A list of all interfaces on which the server shall listen. IPv4 and IPv6 addresses, as well as domain names are supported.

				dt: a(href="api/vibe.http.server/HTTPServerSettings.options"): code.prettyprint options
				dd Controls optional features of the web server. Certain options can be disabled to increase speed or to decrease memory usage. By default, the following options are enabled: parseURL, parseQueryString, parseFormBody, parseJsonBody, parseMultiPartBody, parseCookies. Enabled options are ORed together.

				dt: a(href="api/vibe.http.server/HTTPServerSettings.errorPageHandler"): code.prettyprint errorPageHandler
				dd Provides a way to customize error pages. For example:
					pre.code.prettyprint.lang-d.
						void errorPage(<a href="api/vibe.http.server/HTTPServerRequest">HTTPServerRequest</a> req,
							<a href="api/vibe.http.server/HTTPServerResponse">HTTPServerResponse</a> res,
							<a href="api/vibe.http.server/HTTPServerErrorInfo">HTTPServerErrorInfo</a> error)
						{
							res.<a href="api/vibe.http.server/render">render</a>!("error.dt", req, error);
						}

						void main()
						{
							auto settings = new <a href="api/vibe.http.server/HTTPServerSettings">HTTPServerSettings</a>;
							settings.<a href="api/vibe.http.server/HTTPServerSettings.errorPageHandler">errorPageHandler</a> = toDelegate(&amp;errorPage);
							// ...
						}
					| Inside of the error.dt template, the variables req, code and msg are available in this example.

				dt: a(href="api/vibe.http.server/HTTPServerSettings.tlsContext"): code.prettyprint tlsContext
				dd Lets the server operate as an HTTPS server. You should probably also set the port to 443 in case this field is set.

		section
			h3#http-https HTTPS

			p To serve HTTPS connections, the configuration simply needs to have a TLS context that has the appropriate certificate and private key files set:

			pre.code.prettyprint.lang-d.
				auto settings = new HTTPServerSettings;
				settings.port = 443;
				settings.bindAddresses = ["127.0.0.1"];
				settings.tlsContext = createTLSContext(TLSContextKind.server);
				settings.tlsContext.useCertificateChainFile("server-cert.pem");
				settings.tlsContext.usePrivateKeyFile("server-key.pem");

			h4 Selecting the TLS provider

			p Two TLS providers are currently supported, OpenSSL and the D port of Botan. By default, OpenSSL 1.0.x is used to provide TLS/HTTPS functionality. To select a different provider, or to avoid compiling with TLS support enabled, the appropriate build configuration of the vibe-d:tls sub package needs to be selected:
			pre.code.prettyprint.lang-sdl.
				dependency "vibe-d:tls" version="*"
				subConfiguration "vibe-d:tls" "botan"

			p When using a JSON based package recipe, the two lines have to be inserted as follows (the "&hellip;" are just placeholders for other possible directives):
			pre.code.prettyprint.lang-json.
				{
					&hellip;
					"dependencies": {
						&hellip;
						"vibe-d:tls": "*"
					},
					"subConfigurations": {
						&hellip;
						"vibe-d:tls": "botan"
					}
				}

			p Available configurations:
				dl
					dt: code "notls"
					dd Don't compile with TLS support
					dt: code "openssl"
					dd OpenSSL 1.0.x (default)
					dt: code "openssl-1.1"
					dd OpenSSL 1.1.x
					dt: code "openssl-0.9"
					dd OpenSSL 0.9.8
					dt: code "botan"
					dd D port of Botan

		section
			h3#http-routing Routing

			p The #[a(href="api/vibe.http.router/URLRouter") #[code.prettyprint URLRouter]] class provides a convenient way to let different functions handle different URLs. It supports static path matching, variable placeholders and wild-cards. Any matched variable will be available as an entry in the <a href="api/vibe.http.server/HTTPServerRequest.params"><code class="prettyprint">params</code></a> dictionary.
			p In addition to the path, the HTTP method is also used for matching requests. Each HTTP method has a corresponding method in the #[a(href="api/vibe.http.router/URLRouter") code.prettyprint URLRouter] class (e.g. <a href="api/vibe.http.router/URLRouter.get"><code class="prettyprint">get</code></a> or <a href="api/vibe.http.router/URLRouter.post"><code class="prettyprint">post</code></a>). The following example will route all GET requests matching the path scheme <code class="prettyprint">"/users/*"</code> to the <code class="prettyprint">userInfo</code> handler and serve all other GET requests using the files in the public folder, see <a href="api/vibe.http.fileserver/serveStaticFiles"><code class="prettyprint.lang-d">serveStaticFiles</code></a>.

			pre.code.prettyprint.lang-d.
				import vibe.vibe;

				void userInfo(<a href="api/vibe.http.server/HTTPServerRequest">HTTPServerRequest</a> req, <a href="api/vibe.http.server/HTTPServerResponse">HTTPServerResponse</a> res)
				{
					auto username = req.params["user"];
					<a href="api/vibe.http.server/render">render</a>!("userinfo.dt", username)(res);
				}

				void addUser(<a href="api/vibe.http.server/HTTPServerRequest">HTTPServerRequest</a> req, <a href="api/vibe.http.server/HTTPServerResponse">HTTPServerResponse</a> res)
				{
					<a href="api/vibe.http.common/enforceHTTP">enforceHTTP</a>("user" in req.form, <a href="api/vibe.http.status/HTTPStatus.badRequest">HTTPStatus.badRequest</a>, "Missing user field.");
					res.<a href="api/vibe.http.server/HTTPServerResponse.redirect">redirect</a>("/users/"~req.form["user"]);
				}

				void main()
				{
					auto router = new <a href="api/vibe.http.router/URLRouter">URLRouter</a>;
					router.get("/users/:user", &amp;userInfo);
					router.post("/adduser", &amp;addUser);
					router.get("*", serveStaticFiles("./public/"));

					// To reduce code redundancy, you can also
					// use method chaining:
					router
						.get("/users/:user", &amp;userInfo)
						.post("/adduser", &amp;addUser)
						.get("*", serveStaticFiles("./public/"));

					<a href="api/vibe.http.server/listenHTTP">listenHTTP</a>(new <a href="api/vibe.http.server/HTTPServerSettings">HTTPServerSettings</a>, router);

					<a href="api/vibe.core.core/runApplication">runApplication</a>();
				}
			.caption Example: GET/POST routing and static file serving

		section
			h3#html-templates Diet templates

			p.
				Vibe.d supports HTML templates with a syntax mostly compatible to #[a.extern(href="https://pugjs.org", target="_blank") Pug] templates. They provide a concise way to dynamically generate the HTML code of the final web pages. D expressions and statements can be embedded and the full vibe.d API is available within templates.

			p.
				Templates should reside somewhere inside the 'views' folder of a project. They are then rendered using the #[a(href="api/vibe.http.server/render") #[code.prettyprint render]] function, which takes the template file name as the first template argument, followed by a list of variables that should be available to the template. Finally, it takes a #[a(href="api/vibe.http.server/HTTPServerResponse") #[code.prettyprint HTTPServerResponse]] to render into.

			p.
				The following example shows a number of features of the Diet template compiler. A full reference of the template syntax is found on the #[a(href="templates/diet") Diet templates] page.

			pre.code.lang-diet.
				doctype html
				html
					head
						title My page: \#{pageTitle}
					body
						h1= pageTitle
						p This is the content of this page. The
							| title "\#{pageTitle}" is inserted dynamically.
							| We can also use loops and other D statements:
						block placeholder
						p
							- foreach(i, ch; pageTitle)
								| \#{i+1}. character: \#{ch}
						p.special.small This paragraph has the 'special'
							| and 'small' CSS classes
						p#footer This paragraph has the id 'footer'.
						#somediv.
							I'm a multiline text
							inside the div #somediv
			.caption Example: Template file with dynamic code inserts and several other template features


		section
			h3#http-error-pages Error pages

			p There are three ways in which an error page is sent back to the client:

			ul
				li An exception is thrown from the request handler or while parsing the request. By default, a 500 "Internal Server Error" is returned. By throwing a #[a(href="api/vibe.http.common/HTTPStatusException")< #[code.prettyprint.lang-d HTTPStatusException]], the status code can be customized.
				li The request handler does not write a response. In this case the server automatically returns a 404 "Not Found" error.
				li The request handler manually sets an error status to <a href="api/vibe.http.common/HTTPResponse.statusCode">HTTPServerResponse.statusCode</a> and writes a body. In this case, the error page will be written exactly as specified.

			p The #[a(href="api/vibe.http.server/HTTPServerSettings")< #[code.prettyprint.lang-d HTTPServerSettings]] can be used to provide a custom error page handler. If one is provided, it is called for any of the first two conditions and must render an error page to the response object. If no handler is given, a simple plain-text error page is generated. See the <a href="#http-server-config">HTTP server configuration section</a> for an example.


		section
			h3#http-authentication Authentication

			p Currently, HTTP-Basic-Auth and HTTP-Digest-Auth authentication methods are implemented. Higher level mechanisms such as OAuth will be provided using extension libraries.

			p A simple way to plug authentication into a web application is to use the fall-through feature of the <a hreF="api/vibe.http.router/URLRouter"><code class="prettyprint">URLRouter</code></a>. If the user is properly authenticated, the #[a(href="api/vibe.http.auth.basic_auth/performBasicAuth")< #[code.prettyprint.lang-d performBasicAuth]] function will not do anything and the URLRouter will continue to match the request to all following routes. If, however, there is no authentication or if the username/password pair is not valid, it will throw a #[a(href="api/vibe.http.common/HTTPStatusException")< #[code.prettyprint.lang-d HTTPStatusException]] exception which generates a 403 error page so that the user is prompted with a password dialog on the browser side. The routing stops in this case.

			p Note that it is generally recommended to make use of the <a href="#web">high level web framework</a> when developing web application front ends. See the <a href="https://github.com/vibe-d/vibe.d/tree/master/examples/web">"web" example project</a> for a way to implement session based authentication in such a setting.

			pre.code.prettyprint.lang-d.
				import vibe.vibe;

				bool checkPassword(string user, string password)
				{
					return user == "admin" &amp;&amp; password == "secret";
				}

				void main()
				{
					auto router = new URLRouter;
					// the following two routes are accessible without authentication:
					router.get("/", staticTemplate!"index.dt");
					router.get("/about", staticTemplate!"about.dt");

					// now any request is matched and checked for authentication:
					router.any("*", performBasicAuth("Site Realm", toDelegate(&amp;checkPassword)));

					// the following routes can only be reached if authenticated:
					router.get("/profile", staticTemplate!"profile.dt");
					router.get("/internal", staticTemplate!"internal.dt");

					// ...
				}
			.caption Example: Using HTTP-Basic-Auth to restrict access


		section
			h3#http-sessions Sessions

			p Cookie based HTTP sessions are supported directly by the HTTP server. To be able to use them, you first have to set a #[a(href="api/vibe.http.session/SessionStore")< #[code.prettyprint.lang-d SessionStore]] in the #[a(href="api/vibe.http.server/HTTPServerSettings")< #[code.prettyprint.lang-d HTTPServerSettings]]. Sessions are then established by calling #[a(href="api/vibe.http.server/HTTPServerResponse.startSession") code.prettyprint.lang-d HTTPServerResponse.startSession] and stopped using #[a(href="api/vibe.http.server/HTTPServerResponse.terminateSession") code.prettyprint.lang-d HTTPServerResponse.terminateSession]. The returned #[a(href="api/vibe.http.session/Session")< #[code.prettyprint.lang-d Session]] object behaves as a key value store taking strings as keys and values.

			pre.code.prettyprint.lang-d.
				import vibe.vibe;

				void login(HTTPServerRequest req, HTTPServerResponse res)
				{
					enforceHTTP("username" in req.form &amp;&amp; "password" in req.form,
						HTTPStatus.badRequest, "Missing username/password field.");

					// todo: verify user/password here

					auto session = res.startSession();
					session.set("username", req.form["username"]);
					session.set("password", req.form["password"]);
					res.redirect("/home");
				}

				void logout(HTTPServerRequest req, HTTPServerResponse res)
				{
					if (res.session) res.terminateSession();
					res.redirect("/");
				}

				void checkLogin(HTTPServerRequest req, HTTPServerResponse res)
				{
					// force a redirect to / for unauthenticated users
					if (!req.session)
						res.redirect("/");
				}

				void main()
				{
					auto router = new URLRouter;
					router.get("/", staticTemplate!"index.dt");
					router.post("/login", &amp;login);
					router.post("/logout", &amp;logout);
					// restrict all following routes to authenticated users:
					router.any("*", &amp;checkLogin);
					router.get("/home", staticTemplate!"home.dt");

					auto settings = new HTTPServerSettings;
					settings.sessionStore = new MemorySessionStore;
					// ...
				}
			.caption Example: Using a HTTP session for user authentication


		section
			h3#http-client-requests Client requests

			p Client request are done using the <a href="api/vibe.http.client/requestHTTP"><code class="prettyprint">requestHTTP</code></a> function.

			pre.code.prettyprint.lang-d.
				import vibe.vibe;

				void main()
				{
					requestHTTP("http://google.com",
						(scope #[a(href="api/vibe.http.client/HTTPClientRequest") HTTPClientRequest] req) {
							// could add headers here before sending,
							// write a POST body, or do similar things.
						},
						(scope #[a(href="api/vibe.http.client/HTTPClientResponse") HTTPClientResponse] res) {
							logInfo("Response: %s", res.bodyReader.readAllUTF8());
						}
					);
				}
			.caption Example: Performing a simple HTTP request

			p Note that you can leave off the explicit `HTTPClientRequest` and `HTTPClientResponse` parameter types. They will be inferred automatically by the compiler.

			p A connection pool is used internally in conjunction with persistent HTTP connections (keep-alive) for maximum thoughput.


	section
		h2#web Web framework

		p Based on the low-level HTTP/HTML foundation, the high-level web application framework allows for faster and more solid web application development. It uses a class based declarative approach to avoid the boilerplate code that would otherwise usually be needed. Static typing is exploited as much as possible to avoid conversion errors, or errors accessing wrong runtime keys (such as a non-existent or mistyped form field).

		p The framework comes in two flavors, one for front end development, targeted at generating HTML pages and processing form requests, and one for REST based back end development, providing a transparent JSON/REST based RPC mechanism (client and server). Both of these components share the same basis and use the same approach to map class methods to routes of the <a href="api/vibe.http.router/URLRouter"><code>URLRouter</code></a>.

		p For the usual case, both, the HTTP method and the matching path are inferred from the class method's name. In particular, the name is mapped to a certain HTTP method according to its prefix and the rest of the name is converted to a path name in a <a href="api/vibe.web.common/MethodStyle">configurable style</a>. On top of that, it is possible to use the <a href="api/vibe.web.common/path"><code>@path</code></a> and <a href="api/vibe.web.common/method"><code>@method</code></a> attributes to override these defaults.

		table
			tr
				th HTTP method
				th Corresponding prefixes
			tr
				td GET
				td <code>get</code>, <code>query</code>, getter <code>@property</code> methods, methods named <code>index</code>
			tr
				td POST
				td <code>post</code>, <code>create</code>, <code>add</code>, no prefix
			tr
				td PUT
				td <code>put</code>, <code>set</code>, setter <code>@property</code> methods
			tr
				td PATCH
				td <code>patch</code>, <code>update</code>
			tr
				td DELETE
				td <code>delete</code>, <code>erase</code>, <code>remove</code>


		section
			h3#web-interface-generator Web interface generator

			p The front end web interface generator automatically maps incoming query or POST form fields to method parameters, performing the necessary conversion and validation automatically. On top of that, it offers several convenience functions for rendering Diet templates, handling sessions and performing redirects - without directly accessing the underlying <a href="api/vibe.http.server/HTTPServerRequest"><code class="typ">HTTPServerRequest</code></a> or <a href="api/vibe.http.server/HTTPServerResponse"><code class="typ">HTTPServerResponse</code></a> object. This enables a completely statically checked and clean code style in most cases.

			p For those situations where more control is required, it is possible to simply declare parameters of type <code class="typ">HTTPServerRequest</code> or <code class="typ">HTTPServerResponse</code> to give a method full access. Note that this is in contrast to the REST interface generator covered below, which cannot give access to the request/response without losing the ability to generate the client side of the REST protocol. It does, however, provide a way to get around this, using the <a href="api/vibe.web.rest/before"><code>@before</code></a> attribute.

			pre.code.prettyprint.lang-d.
				import vibe.http.router;
				import vibe.http.server;
				import vibe.web.web;

				void main()
				{
					auto router = new URLRouter;
					router.<a href="api/vibe.web.web/registerWebInterface">registerWebInterface</a>(new WebInterface);

					auto settings = new HTTPServerSettings;
					settings.port = 8080;
					settings.sessionStore = new MemorySessionStore;
					listenHTTP(settings, router);
				}

				class WebInterface {
					private {
						// stored in the session store
						<a href="api/vibe.web.web/SessionVar">SessionVar</a>!(bool, "authenticated") ms_authenticated;
					}

					// GET /
					void index()
					{
						bool authenticated = ms_authenticated;
						<a href="api/vibe.web.web/render">render</a>!("index.dt", authenticated);
					}

					// POST /login (username and password are automatically read as form fields)
					void postLogin(string username, string password)
					{
						enforceHTTP(username == "user" &amp;&amp; password == "secret",
							HTTPStatus.forbidden, "Invalid user name or password.");
						ms_authenticated = true;
						<a href="api/vibe.web.web/redirect">redirect</a>("/");
					}

					// POST /logout
					@method(HTTPMethod.POST) @path("logout")
					void postLogout()
					{
						ms_authenticated = false;
						<a href="api/vibe.web.web/terminateSession">terminateSession</a>();
						<a href="api/vibe.web.web/redirect">redirect</a>("/");
					}
				}
			.caption Example: source/app.d

			pre.code.lang-diet.
				doctype 5
				html
					head
						title Welcome
					body
						h1 Welcome

						- if (authenticated)
							form(action="logout", method="POST")
								button(type="submit") Log out
						- else
							h2 Log in
							form(action="login", method="POST")
								p User name:
									input(type="text", name="username")
								p Password:
									input(type="password", name="password")
								button(type="submit")
			.caption Example: views/index.dt

		section
			h3#web-localization Localization

			p Using <a href="https://www.gnu.org/software/gettext/">GNU gettext</a> compatible .po translation files, it's possible to localize Diet templates at compile time. This just requires putting the translation files with the naming scheme <code>&lt;name&gt;.&lt;language&gt;.po</code> into a path that is registered in the <code>"stringImportPaths"</code> field of the dub.json. <code>&lt;language&gt;</code> must be a language identifier of the form <code>en_US</code>.

			pre.code.prettyprint.lang-d.
				import vibe.web.web;

				struct TranslationContext {
					alias languages = TypeTuple!("en_US", "de_DE");
					mixin <a href="api/vibe.web.i18n/translationModule">translationModule</a>!"example";
				}

				<a href="api/vibe.web.i18n/translationContext">@translationContext</a>!TranslationContext
				class WebInterface {
					void index()
					{
						<a href="api/vibe.web.web/render">render</a>!("index.dt");
					}
				}
			.caption Example: source/app.d

			pre.code.lang-diet.
				doctype 5
				html
					head
						title& Welcome
					body
						h1& Welcome

						p& home.welcome.text
			.caption Example: views/index.dt

			pre.code.
				msgid "Welcome"
				msgstr "Welcome"

				msgid "home.welcome-text"
				msgstr "Hello, this is a translation example."
			.caption Example: translations/example.en_US.po

			pre.code.
				msgid "Welcome"
				msgstr "Willkommen"

				msgid "home.welcome-text"
				msgstr "Hallo, dies ist ein Übersetzungs-Beispiel."
			.caption Example: translations/example.de_DE.po


		section
			h3#rest-interface-generator REST interface generator

			p Similar to the browser oriented web interface generator, there is a machine communication oriented JSON/REST based interface generator. Method parameters are mapped to JSON fields and get serialized according to the usual <a href="api/vibe.data.serialization/">serialization rules</a>. In addition to the interface generator, there is also a client generator, which automatically implements a class that emits the proper REST calls to access the REST interface.

			pre.code.prettyprint.lang-d.
				import vibe.core.core;
				import vibe.core.log;
				import vibe.http.router;
				import vibe.http.server;
				import vibe.web.rest;

				struct Weather {
					string text;
					double temperature; // °C
				}

				interface MyAPI {
					// GET /weather -&gt; responds {"text": "...", "temperature": ...}
					Weather getWeather();

					// PUT /location -&gt; accepts {"location": "..."}
					@property void location(string location);

					// GET /location -&gt; responds "..."
					@property string location();
				}

				class MyAPIImplementation : MyAPI {
					private {
						string m_location;
					}

					Weather getWeather() { return Weather("sunny", 25); }

					@property void location(string location) { m_location = location; }
					@property string location() { return m_location; }
				}

				void main()
				{
					auto router = new URLRouter;
					router.<a href="api/vibe.web.rest/registerRestInterface">registerRestInterface</a>(new MyAPIImplementation);

					auto settings = new HTTPServerSettings;
					settings.port = 8080;
					listenHTTP(settings, router);

					// create a client to talk to the API implementation over the REST interface
					runTask({
						auto client = new <a href="api/vibe.web.rest/RestInterfaceClient">RestInterfaceClient</a>!MyAPI("http://127.0.0.1:8080/");
						auto weather = client.getWeather();
						logInfo("Weather: %s, %s °C", weather.text, weather.temperature);
						client.location = "Paris";
						logInfo("Location: %s", client.location);
					});

					runApplication();
				}


	section
		h2#db-support Database support

		section
			h3#mongo MongoDB

			p A native #[a.extern(href="https://www.mongodb.org/", target="_blank") MongoDB] driver is part of the distribution supporting the standard set of database operations. Data is exchanged using the #[a(href="api/vibe.data.bson/Bson")< #[code.prettyprint.lang-d Bson]] struct.

			p For an comprehensive documentation of MongoDB's operations see the #[a.extern(href="https://www.mongodb.org/display/DOCS/Manual", target="_blank") MongoDB manual]. The #[a(href="api/vibe.db.mongo.mongo/connectMongoDB") API reference] contains the documentation for the driver.

			pre.code.prettyprint.lang-d.
				import vibe.vibe;

				void main()
				{
					MongoClient client = connectMongoDB("127.0.0.1");

					auto coll = client.getCollection("test.collection");

					foreach (doc; coll.find(["name": "Peter"]))
						logInfo("Found entry: %s", doc.toJson());
				}
			.caption Example: Finding entries in a MongoDB

		section
			h3#redis Redis

			p A client for the structured storage server #[a.extern(href="https://redis.io", target="_blank") Redis] is included in vibe.d. Commands and operations on Redis data types are implemented as instance methods of the <a href="api/vibe.db.redis.redis/RedisClient">client</a> and of the <a href="api/vibe.db.redis.redis/RedisDatabase"><code>RedisDatabase</code></a> class. The methods are named after their corresponding Redis command documented in the #[a.extern(href="https://redis.io/commands", target="_blank") command reference].

			p On top of the low level interface, two high level modules, <a href="api/vibe.db.redis.types/"><code>types</code></a> and <a href="api/vibe.db.redis.idioms/"><code>idioms</code></a> are available to solve common tasks in a more convenient and type safe way. In addition to that, a <a href="api/vibe.db.redis.sessionstore/RedisSessionStore">Redis based HTTP session store</a> is also included.

	section
		h2#raw-tcp Raw TCP

		p Low level TCP connections are handled using the #[a(href="api/vibe.core.net/TCPConnection")< #[code.prettyprint.lang-d TCPConnection]] class, which implements the #[a(href="api/vibe.core.stream/ConnectionStream")< #[code.prettyprint.lang-d ConnectionStream]] interface. Connections can be established by either listening on a specific port for incoming connections or by actively connecting to a remote server.

		section
			h3#tcp-server Server

			p Listening for TCP connections is done using the #[a(href="api/vibe.core.net/listenTCP")< #[code.prettyprint.lang-d listenTCP]] function. An implementation of a very simple echo server could look like this:

			pre.code.prettyprint.lang-d.
				import vibe.vibe;

				void main()
				{
					listenTCP(7, (conn) { conn.write(conn) });
					runApplication();
				}

			p Calling #[a(href="api/vibe.core.net/listenTCP")< #[code.prettyprint.lang-d listenTCP]] like this will listen on all local network devices. To listen only on a specific device, the bind address can be given as an additional parameter:
			pre.code.prettyprint.lang-d.
				import vibe.vibe;

				void main()
				{
					listenTCP(7, conn =&gt; conn.write(conn), "127.0.0.1");
					runApplication();
				}

			p The address can be given as either an IPv4 or an IPv6 address string.

		section
			h3#tcp-client Client

			p Connecting to a TCP server is done with the #[a(href="api/vibe.core.net/connectTCP")< #[code.prettyprint.lang-d connectTCP]] function. The following example gets the current time using the #[a.extern(href="https://en.wikipedia.org/wiki/Daytime_Protocol", target="_blank") Daytime Protocol].
			pre.code.prettyprint.lang-d.
				import vibe.vibe;

				void main()
				{
					auto conn = connectTCP("time-c.nist.gov", 13);
					logInfo("The time is: %s", conn.readAllUTF8());
				}


	section
		h2#raw-udp Raw UDP

		p In addition to stream based TCP connections, packet based UDP communication is also supported. To open a UDP socket, use the #[a(href="api/vibe.core.net/listenUDP")< #[code.prettyprint.lang-d listenUDP]] function with the appropriate port. It will return a #[a(href="api/vibe.core.net/UDPConnection")< #[code.prettyprint.lang-d UDPConnection]] instance, which can then be used to send and receive individual packets.

		pre.code.prettyprint.lang-d.
			import vibe.appmain;
			import vibe.core.core;
			import vibe.core.log;
			import vibe.core.net;

			import core.time;


			void main()
			{
				runTask({
					auto udp_listener = listenUDP(1234);
					while (true) {
						auto pack = udp_listener.recv();
						logInfo("Got packet: %s", cast(string)pack);
					}
				});

				runTask({
					auto udp_sender = listenUDP(0);
					udp_sender.connect("127.0.0.1", 1234);
					while (true) {
						sleep(dur!"msecs"(500));
						logInfo("Sending packet...");
						udp_sender.send(cast(ubyte[])"Hello, World!");
					}
				});

				runApplication();
			}
		.caption Example: Simple UDP based communication on localhost


	section
		h2#advanced Advanced topics

		section
			h3#dub-publishing Publishing on the DUB registry

			p.
				The #[a.extern(href="https://code.dlang.org/", target="_blank") DUB registry] contains packages
				that use the same package management as vibe.d. Many of them extend and supplement vibe.d's
				functionality. The packages are automatically downloaded if the corresponding entry in the
				"dependencies" section of the project's dub.json file is present.

			p If you have written an extension library yourself, you can register it in the DUB registry so others can easily make use of it. For this to work, you will first have to write a proper dub.json, which has to reside in the root directory of your project (the project should adhere to the structure mentioned in the <a href="#first-steps">first steps</a>). The project currently also has to be hosted either on GitHub or on BitBucket. See <a href="https://code.dlang.org/publish">https://code.dlang.org/publish</a> for more information.

			pre.code.
				{
					"name": "vibelog",
					"description": "A light-weight embeddable blog implementation",
					"homepage": "https://github.com/rejectedsoftware/vibelog",
					"license": "AGPL-3.0",
					"authors": [
						"Sönke Ludwig"
					],
					"dependencies": {
						"vibe-d": "~&gt;0.7.23"
					}
				}
			.caption Example: A dub.json file suitable for registration as a DUB package.

			p.
				You can then register your project on #[a.extern(href="https://code.dlang.org/", target="_blank") code.dlang.org]
				and as soon as you then add a new #[a.extern(href="https://learn.github.com/p/tagging.html", target="_blank") git tag]
				with the name matching the current version prefixed with "v" ("v0.0.1" for the example here), it
				should appear there. Note that the update can take up to 30 minutes. Anyone can then add an entry
				similar to the following to their project to make use of the library:

			pre.code.
				{
					...
					"dependencies": {
						"vibelog": "&gt;=0.0.1"
					}
				}
			.caption Example: Corresponding dependency to use the published DUB package.

		section
			h3#custom-main The main function

			p To simplify development of server-like applications that are command line based and run an event loop, vibe.d includes a default application entry point (<code>main()</code>). To use it, define the version <code>VibeDefaultMain</code> when building the project. This can be done by simply adding the following entry to your package description file: <code>"versions": ["VibeDefaultMain"]</code>. However, note that for new applications it is recommended to define a regular `main` function instead and call <a href="api/vibe.core.core/runApplication"><code>runApplication</code></a> to initialize and run the vibe.d event loop.

			p When writing a pure command line client application, maybe something like <a href="https://www.gnu.org/software/wget/">wget</a>, it may not be desirable to start an explicit event loop, but instead exit right after the work is done. In this case, vibe.d will automatically run a temporary event loop as long as any blocking operation is in progress, so that no explicit <code>runApplication</code> or <code>runEventLoop</code> calls are necessary.

			pre.code.prettyprint.lang-d.
				import vibe.vibe;

				void main()
				{
					// ... perform setup here ...
					runApplication();
				}
			.caption Example: Simple custom main function that runs an event loop.

			pre.code.prettyprint.lang-d.
				import vibe.vibe;

				void main()
				{
					auto f = openFile("test.html", FileMode.CreateTrunc);
					f.write(download("http://google.com/"));
				}
			.caption Example: Client application that downloads a document

		section
			h3#privilege-lowering Privilege lowering

			p For server applications it may be desirable to start the application as root so that it can listen on privileged ports or open system log files for writing. After these setup tasks, such applications impose a security risk because a hole in the application that allows to somehow execute malicious commands on the server will give the attacker full access to the system. For this reason vibe.d supports privilege lowering, where the user id and group id of the process are changed to an unprivileged user after the startup process, right before the event loop is started.

			p Privilege lowering can be configured in the configuration file /etc/vibe/vibe.conf (on Windows vibe.conf must be in the application's root directory instead). The two fields "user" and "group" have to be set to the the name or numeric ID of the unprivileged user/group.

			pre.code.
				{
					"user": "www-data",
					"group": "www-data"
				}
			.caption Example vibe.conf file

		section
			h3#compile-time-configuration Compile time configuration

			p There is a number of features that can be controlled via "versions". To defined a certain version, add the corresponding entry to the <code>"versions"</code> in your dub.json:
			pre.code.
				{
					...
					"versions": ["VibeManualMemoryManagement", "VibeDefaultMain"],
					...
				}
			.caption Declaring a "version" in dub.json

			table
				tr
					th Version constant
					th Meaning

				tr
					td: code VibeDefaultMain
					td Tells vibe.d to use its own predefined <code>main</code> function. This is mutually exclusive to <code>VibeCustomMain</code>.

				tr
					td: code VibeDisableCommandLineParsing
					td Disables automatic parsing of command line options passed to the application, such as "--help" or "--verbose".

				tr
					td: code VibeNoDefaultArgs
					td Disables all default command line options, but keeps the command line argument module functional.

				tr
					td: code VibeManualMemoryManagement
					td Performs a number of operations using manual memory management instead of the garbage collector, most notably in the HTTP server. This can lead to considerable performance improvements, but also makes certain operations unsafe and thus may open up the possibility for certain attacks. Especially any code needs to make sure to not escape any data (including <code>string</code> data) from <a href="api/vibe.http.server/HTTPServerRequest"><code>HTTPServerRequest</code></a>.

				tr
					td: code VibeIdleCollect
					td Perform manual garbage collection runs when the application is idle for more than two seconds.

				tr
					td: code VibePartialAutoExit
					td Partial workaround for issue <a href="https://github.com/vibe-d/vibe.d/issues/212">#212</a> - exits the event loop after no mode file and socket based events exist. Note that this will exit the event loop, even if other kinds of events, such as timers, are still active. It is currently recommended to explicitly use <a href="api/vibe.core.core/exitEventLoop"><code>exitEventLoop</code></a> instead.

				tr
					td: code VibeJsonFieldNames
					td Stores field names for JSON values for better error messages. This will use a few bytes of additional memory per <a href="api/vibe.data.json/Json"><code>Json</code></a> value.

				tr
					td: code JsonLineNumbers
					td Stores line numbers for each JSON value parsed from a JSON string for improved error messages. This will store an additional <code>int</code> for each <a href="api/vibe.data.json/Json"><code>Json</code></a> value.

				tr
					td: code VibeOutputCompactHTML
					td Instructs #[a(href="api/diet.html/") Diet-NG] to output compact HTML (no extraneous white space) by default

				tr
					td: code VibeDebugCatchAll
					td Enables catching of exceptions that derive from <code>Error</code>. This can be useful during application development to get useful error information while keeping the application running, but can generally be dangerous, because the application may be left in a bad state after an <code>Error</code> has been thrown.

				tr
					td: code VibePragmaLib
					td Uses a <code>pragma(lib)</code> to link against OpenSSL. This is only useful for building without DUB.

				tr
					td: code: del VibeCustomMain
					td #[del Tells vibe.d to not use its own predefined #[code main] function. This is mutually exclusive to #[code VibeDefaultMain].] This is the default behavior since vibe.d 0.7.26.

				tr
					td: code: del VibeNoSSL
					td #[del Does not use OpenSSL to provide TLS/SSL functionality. The #[code vibe.stream.tls] module will be dysfunctional.] Deprecated for 0.8.0 and up, see the #[a(href="#http-https") HTTPS section] instead

				tr
					td: code: del VibeUseOpenSSL11
					td #[del Compiles the TLS module so that it is compatible with the 1.1.x branch of OpenSSL.] Deprecated for 0.8.0 and up, see the #[a(href="#http-https") HTTPS section] instead

				tr
					td: code: del VibeUseOldOpenSSL
					td #[del Disables the use of features introduced in OpenSSL 1.0.1 or later, most notably ECDH curve selection. Use this to link against old versions of the OpenSSL library.] Deprecated for 0.8.0 and up, see the #[a(href="#http-https") HTTPS section] instead

				tr
					td: code: del VibeLibevDriver
					td #[del Enables the libev based event driver (not fully functional).] This driver has been removed.

				tr
					td: code: del VibeLibeventDriver
					td #[del Enables the libevent based event driver (currently the default).] Do not use this version directly, but select the "libevent" configuration in your dub.json instead.

				tr
					td: code: del VibeWin32Driver
					td #[del Enables the Win32 based event driver (provides GUI message support on Windows).] Do not use this version directly, but select the "win32" configuration in your dub.json instead.

				tr
					td: code: del VibeWinrtDriver
					td #[del Enables the WinRT based event driver (not yet implemented).] This driver has been removed


		section
			h3#handling-segmentation-faults Handling segmentation-faults on Linux

			p While access violations on Windows usually trigger an exception with a convenient stack trace, on other operating systems D applications just terminate and possibly cause a core dump file to be written. However, there is a module hidden in the D runtime that enables such a stack trace also on Linux. Simply run the following code at program initialization:

			pre.code.prettyprint.lang-d.
				import etc.linux.memoryerror;
				static if (is(typeof(registerMemoryErrorHandler)))
					registerMemoryErrorHandler();

			p This currently works only on Linux x86 and x86-64.
