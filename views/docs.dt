extends layout

block title
	- title = "Documentation";

block vibed.navigation
	ul.bs-local
		li
			a(href="api/") API Reference
		li.bs-separator
			a(href="#first-steps") First steps
		li
			a(href="#examples") Example projects
		li
			a(href="#http") HTTP
			ul
				li
					a(href="#http-server-config") Server configuration
				li
					a(href="#http-routing") Routing
				li
					a(href="#html-templates") Templates
				li
					a(href="#http-error-pages") Error pages
				li
					a(href="#http-authentication") Authentication
				li
					a(href="#http-sessions") Sessions
				li
					a(href="#http-client-requests") Client requests
		li
			a(href="#web") Web framework
			ul
				li
					a(href="#web-interface-generator") Web interface generator
				li
					a(href="#web-localization") Localization
				li
					a(href="#rest-interface-generator") REST interface generator
		li
			a(href="#db-support") Database support
			ul
				li
					a(href="#mongo") MongoDB
				li
					a(href="#redis") Redis
		li
			a(href="#raw-tcp") Raw TCP
			ul
				li
					a(href="#tcp-server") Server
				li
					a(href="#tcp-client") Client
		li
			a(href="#raw-udp") Raw UDP
		li
			a(href="#advanced") Advanced topics
			ul
				li
					a(href="#dub-publishing") Publishing on the DUB registry
				li
					a(href="#custom-main") The main function
				li
					a(href="#privilege-lowering") Privilege lowering
				li
					a(href="#compile-time-configuration") Compile time configuration
				li
					a(href="#handling-segmentation-faults") Handling segmentation faults on Linux
		li.bs-separator
			a(href="templates/diet") Diet Reference
		li.bs-separator
			a.extern(href="http://dlang.org/phobos/index.html", target="_blank") D Library Reference

block vibed.body
	section
		h2#first-steps First steps

		p First, install the <a href="https://github.com/rejectedsoftware/dub/">DUB package manager</a> to let it handle downloading and building of vibe.d and derived applications. On non-Windows systems, a number of additional dependencies needs to be installed. See the <a href="https://github.com/rejectedsoftware/vibe.d#installation">project description on GitHub</a> for details.

		p Manual building (e.g. using RDMD) is a possible alternative, but you have to make sure that external libraries are linked in (such as libevent) and that a version identifier for the used driver is passed to the compiler (e.g. <code>-version=VibeLibeventDriver</code>). Take a look at <a href="https://github.com/rejectedsoftware/vibe.d/blob/master/dub.json">vibe.d's dub.json</a> to determine how to build on a certain platform, or, alterntaively, run DUB with the <code>-v</code> switch to see the actual compiler command line.

		p The easiest way to get started is to run the following command from your projects directory:

		pre.code.
			cd /path/to/my/projects
			dub init &lt;project-name&gt; -t vibe.d

		p This will create a new directory with the given name and creates the basic directory structure that is recommended for vibe.d projects. Running it will start up an HTTP server on port 8080, serving a simple plain-text page. As the next step, you can go ahead and edit the <code>source/app.d</code> file. If you want to publish your project, you should also edit the <code>dub.json</code>/<code>dub.sdl</code> file and properly fill in all fields, including a "license" field.

		p Once you have the project in place, simply run DUB from the project's root directory and it will get all dependencies, compile the application, and run it:
		pre.code.
			cd path/to/project
			dub
			<span class="com">Performing "debug" build using dmd for x86_64.
			vibe-d 0.7.26: target for configuration "libevent" is up to date.
			vibedtest ~master: building configuration "application"...
			Linking...
			To force a rebuild of up-to-date targets, run again with --force.
			Running ./vibedtest 
			Listening for requests on http://::1:8080
			Listening for requests on http://127.0.0.1:8080
			Please open http://127.0.0.1:8080/ in your browser.</span>

		h3 Recommended project structure

		p The recommended directory structure for a project, which the "dub init" command establishes, is separated into three base folders:

		pre.code.
			appname/
				source/
					app.d
				public/
					images/
					styles/
						style.css
				views/
					layout.dt
					index.dt
				dub.json
		.caption Example structure of a web application project

		p For a simple web application, the 'app.d' file could look similar to this one:
		
		pre.code.prettyprint.lang-d.
			import vibe.d;
			
			void index(<a href="api/vibe.http.server/HTTPServerRequest">HTTPServerRequest</a> req, <a href="api/vibe.http.server/HTTPServerResponse">HTTPServerResponse</a> res)
			{
				res.<a href="api/vibe.http.server/render">render</a>!("index.dt", req);
			}
			
			shared static this()
			{
				auto router = new <a href="api/vibe.http.router/URLRouter">URLRouter</a>;
				router.get("/", &amp;index);
			
				auto settings = new <a href="api/vibe.http.server/HTTPServerSettings">HTTPServerSettings</a>;
				settings.port = 8080;
			
				<a href="api/vibe.http.server/listenHTTP">listenHTTP</a>(settings, router);
			}
		.caption Simple app.d file with minimal routing

		p The 'views' sub folder is automatically searched for templates instantiated with <a href="api/vibe.http.server/render"><code class="prettyprint">render</code></a>. The two templates in the example structure might look like this:

		pre.code.lang-diet.
			doctype html
			html
				head
					title Example page
				body
					block body
		.caption Example layout.dt

		pre.code.lang-diet.
			extends layout
			
			block body
				h1 Example page - Home
				p Hello, World!
		.caption Example index.dt

		p This structure makes use of the blocks/extensions feature of the <a href="#html-templates">Diet template</a> compiler. For more advanced template features see the <a href="templates/diet">Diet template documentation</a>.
			
		p Finally, the "dub.json" lets the vibe.d package manager automatically download and compile dependency libraries. This file will also provide the description that is needed to later put your own library into the <a href="http://code.dlang.org/">public extension registry</a>.
		
		pre.code.prettyprint.lang-javascript.
			{
				"name": "appname",
				"description": "My fabulous new app",
				"copyright": "Copyright (C) 2000 Me. All rights reserved.",
				"license": "AGPL-3.0",
				"homepage": "http://appname.org",
				"authors": ["Hans Wurst"],
				"dependencies": {
					"vibe-d": "~&gt;0.7.23"
				},
				"versions": ["VibeDefaultMain"]
			}
		.caption Example dub.json

		p DUB also provides support for a new alternative syntax using <a target="_blank" class="extern" href="https://sdlang.org/">SDLang</a>, which supports comments and is considerably more compact. The filename to use is "dub.sdl" in this case:
		pre.code.prettyprint.lang-javascript.
			name "appname"
			description "My fabulous new app"
			copyright "Copyright (C) 2000 Me. All rights reserved."
			license "AGPL-3.0"
			homepage "http://appname.org"
			authors "Hans Wurst"
			dependency "vibe-d" version="~&gt;0.7.23"
			versions "VibeDefaultMain"
		.caption Example dub.sdl

	section
		h2#examples Example projects

		p A library of example projects is maintained in the Git repository. Most things not covered in this document can be found there in the form of code:
			a.extern(href="https://github.com/rejectedsoftware/vibe.d/tree/master/examples", target="_blank") Example projects

		p To run the examples locally, you can either download the <a href="https://github.com/rejectedsoftware/vibe.d/archive/master.zip">repository as a zip file</a>, or use GIT to get the examples:

		pre.
			git clone https://github.com/rejectedsoftware/vibe.d.git

		p To run the "http_server" example, type:

		pre.
			dub run --root=vibe.d/examples/http_server


	section
		h2#http HTTP

		section
			h3#http-server-config Server configuration

			p The HTTP server supports a number of configuration options to customize its behavior. By default, the server will listen on all local network adapters on port 80 and will perform complete request parsing. The following list gives an overview of the most common settings:
			
			dl.feat
				dt
					a(href="api/vibe.http.server/HTTPServerSettings.port")
						code.prettyprint port
				dd The port on which the HTTP server shall listen
				
				dt
					a(href="api/vibe.http.server/HTTPServerSettings.bindAddresses")
						code.prettyprint bindAddresses
				dd A list of all interfaces on which the server shall listen. IPv4 and IPv6 addresses, as well as domain names are supported.

				dt
					a(href="api/vibe.http.server/HTTPServerSettings.options")
						code.prettyprint options
				dd Controls optional features of the web server. Certain options can be disabled to increase speed or to decrease memory usage. By default, the following options are enabled: parseURL, parseQueryString, parseFormBody, parseJsonBody, parseMultiPartBody, parseCookies. Enabled options are ORed together.

				dt
					a(href="api/vibe.http.server/HTTPServerSettings.errorPageHandler")
						code.prettyprint errorPageHandler
				dd Provides a way to customize error pages. For example:
					pre.code.prettyprint.lang-d.
						void errorPage(<a href="api/vibe.http.server/HTTPServerRequest">HTTPServerRequest</a> req,
							<a href="api/vibe.http.server/HTTPServerResponse">HTTPServerResponse</a> res,
							<a href="api/vibe.http.server/HTTPServerErrorInfo">HTTPServerErrorInfo</a> error)
						{
							res.<a href="api/vibe.http.server/render">render</a>!("error.dt", req, error);
						}
						
						shared static this()
						{
							auto settings = new <a href="api/vibe.http.server/HTTPServerSettings">HTTPServerSettings</a>;
							settings.<a href="api/vibe.http.server/HTTPServerSettings.errorPageHandler">errorPageHandler</a> = toDelegate(&amp;errorPage);
							// ...
						}
					| Inside of the error.dt template, the variables req, code and msg are available in this example.

				dt
					a(href="api/vibe.http.server/HTTPServerSettings.sslContext")
						code.prettyprint sslContext
				dd Lets the server operate as an HTTPS server. You should probably also set the port to 443 in case this field is set.

		section
			h3#http-routing Routing

			p The
				a(href="api/vibe.http.router/URLRouter")
					code.prettyprint URLRouter
				| class provides a convenient way to let different functions handle different URLs. It supports static path matching, variable placeholders and wild-cards. Any matched variable will be available as an entry in the <a href="api/vibe.http.server/HTTPServerRequest.params"><code class="prettyprint">params</code></a> dictionary.
			p In addition to the path, the HTTP method is also used for matching requests. Each HTTP method has a corresponding method in the
				a(href="api/vibe.http.router/URLRouter")
					code.prettyprint URLRouter
				| class (e.g. <a href="api/vibe.http.router/URLRouter.get"><code class="prettyprint">get</code></a> or <a href="api/vibe.http.router/URLRouter.post"><code class="prettyprint">post</code></a>). The following example will route all GET requests matching the path scheme <code class="prettyprint">"/users/*"</code> to the <code class="prettyprint">userInfo</code> handler and serve all other GET requests using the files in the public folder, see <a href="api/vibe.http.fileserver/serveStaticFiles"><code class="prettyprint.lang-d">serveStaticFiles</code></a>.

			pre.code.prettyprint.lang-d.
				import vibe.d;
				
				void userInfo(<a href="api/vibe.http.server/HTTPServerRequest">HTTPServerRequest</a> req, <a href="api/vibe.http.server/HTTPServerResponse">HTTPServerResponse</a> res)
				{
					auto username = req.params["user"];
					<a href="api/vibe.http.server/render">render</a>!("userinfo.dt", username)(res);
				}
				
				void addUser(<a href="api/vibe.http.server/HTTPServerRequest">HTTPServerRequest</a> req, <a href="api/vibe.http.server/HTTPServerResponse">HTTPServerResponse</a> res)
				{
					<a href="api/vibe.http.common/enforceHTTP">enforceHTTP</a>("user" in req.form, <a href="api/vibe.http.status/HTTPStatus.badRequest">HTTPStatus.badRequest</a>, "Missing user field.");
					res.<a href="api/vibe.http.server/HTTPServerResponse.redirect">redirect</a>("/users/"~req.form["user"]);
				}
				
				shared static this()
				{
					auto router = new <a href="api/vibe.http.router/URLRouter">URLRouter</a>;
					router.get("/users/:user", &amp;userInfo);
					router.post("/adduser", &amp;addUser);
					router.get("*", serveStaticFiles("./public/"));
				
					// To reduce code redundancy, you can also
					// use method chaining:
					router
						.get("/users/:user", &amp;userInfo)
						.post("/adduser", &amp;addUser)
						.get("*", serveStaticFiles("./public/"));
				
					<a href="api/vibe.http.server/listenHTTP">listenHTTP</a>(new <a href="api/vibe.http.server/HTTPServerSettings">HTTPServerSettings</a>, router);
				}
			.caption Example: GET/POST routing and static file serving

		section
			h3#html-templates Diet templates

			p Vibe.d supports HTML templates with a syntax mostly compatible to
				a.extern(href="https://pugjs.org", target="_blank") Pug
				| templates. They provide a concise way to dynamically generate the HTML code of the final web pages. D expressions and statements can be embedded and the full vibe.d API is available within templates.

			p Templates should reside somewhere inside the 'views' folder of a project. They are then rendered using the
				a(href="api/vibe.http.server/render")
					code.prettyprint render
				| function, which takes the template file name as the first template argument, followed by a list of variables that should be available to the template. Finally, it takes a
				a(href="api/vibe.http.server/HTTPServerResponse")
					code.prettyprint HTTPServerResponse
				| to render into.

			p The following example shows a number of features of the Diet template compiler. A full reference of the template syntax is found on the
				a(href="templates/diet") Diet templates
				| page.

			pre.code.lang-diet.
				doctype html
				html
					head
						title My page: \#{pageTitle}
					body
						h1= pageTitle
						p This is the content of this page. The
							| title "\#{pageTitle}" is inserted dynamically.
							| We can also use loops and other D statements:
						block placeholder
						p
							- foreach(i, ch; pageTitle)
								| \#{i+1}. character: \#{ch}
						p.special.small This paragraph has the 'special'
							| and 'small' CSS classes
						p#footer This paragraph has the id 'footer'.
						#somediv.
							I'm a multiline text
							inside the div #somediv
			.caption Example: Template file with dynamic code inserts and several other template features

				
		section
			h3#http-error-pages Error pages
			
			p There are three ways in which an error page is sent back to the client:
			
			ul
				li An exception is thrown from the request handler or while parsing the request. By default, a 500 "Internal Server Error" is returned. By throwing a
					a(href="api/vibe.http.common/HTTPStatusException")
						code.prettyprint.lang-d HTTPStatusException
					|, the status code can be customized.
				li The request handler does not write a response. In this case the server automatically returns a 404 "Not Found" error.
				li The request handler manually sets an error status to <a href="api/vibe.http.common/HTTPResponse.statusCode">HTTPServerResponse.statusCode</a> and writes a body. In this case, the error page will be written exactly as specified.
			
			p The
				a(href="api/vibe.http.server/HTTPServerSettings")
					code.prettyprint.lang-d HTTPServerSettings
				| can be used to provide a custom error page handler. If one is provided, it is called for any of the first two conditions and must render an error page to the response object. If no handler is given, a simple plain-text error page is generated. See the <a href="#http-server-config">HTTP server configuration section</a> for an example.

			
		section
			h3#http-authentication Authentication
			
			p Currently, HTTP-Basic-Auth and HTTP-Digest-Auth authentication methods are implemented. Higher level mechanisms such as OAuth will be provided using extension libraries.

			p A simple way to plug authentication into a web application is to use the fall-through feature of the <a hreF="api/vibe.http.router/URLRouter"><code class="prettyprint">URLRouter</code></a>. If the user is properly authenticated, the
				a(href="api/vibe.http.auth.basic_auth/performBasicAuth")
					code.prettyprint.lang-d performBasicAuth
				| function will not do anything and the URLRouter will continue to match the request to all following routes. If, however, there is no authentication or if the username/password pair is not valid, it will throw a
				a(href="api/vibe.http.common/HTTPStatusException")
					code.prettyprint.lang-d HTTPStatusException
				| exception which generates a 403 error page so that the user is prompted with a password dialog on the browser side. The routing stops in this case.

			p Note that it is generally recommended to make use of the <a href="#web">high level web framework</a> when developing web application front ends. See the <a href="https://github.com/rejectedsoftware/vibe.d/tree/master/examples/web">"web" example project</a> for a way to implement session based authentication in such a setting.
			
			pre.code.prettyprint.lang-d.
				import vibe.d;
				
				bool checkPassword(string user, string password)
				{
					return user == "admin" &amp;&amp; password == "secret";
				}
				
				shared static this()
				{
					auto router = new URLRouter;
					// the following two routes are accessible without authentication:
					router.get("/", staticTemplate!"index.dt");
					router.get("/about", staticTemplate!"about.dt");
				   
					// now any request is matched and checked for authentication:
					router.any("*", performBasicAuth("Site Realm", toDelegate(&amp;checkPassword)));
				
					// the following routes can only be reached if authenticated:
					router.get("/profile", staticTemplate!"profile.dt");
					router.get("/internal", staticTemplate!"internal.dt");
				
					// ...
				}
			.caption Example: Using HTTP-Basic-Auth to restrict access
			

		section
			h3#http-sessions Sessions
			
			p Cookie based HTTP sessions are supported directly by the HTTP server. To be able to use them, you first have to set a
				a(href="api/vibe.http.session/SessionStore")
					code.prettyprint.lang-d SessionStore
				| in the
				a(href="api/vibe.http.server/HTTPServerSettings")
					code.prettyprint.lang-d HTTPServerSettings
				|. Sessions are then established by calling
				a(href="api/vibe.http.server/HTTPServerResponse.startSession")
					code.prettyprint.lang-d HTTPServerResponse.startSession
				| and stopped using
				a(href="api/vibe.http.server/HTTPServerResponse.terminateSession")
					code.prettyprint.lang-d HTTPServerResponse.terminateSession
				|. The returned
				a(href="api/vibe.http.session/Session")
					code.prettyprint.lang-d Session
				| object behaves as a key value store taking strings as keys and values.
			
			pre.code.prettyprint.lang-d.
				import vibe.d;
				
				void login(HTTPServerRequest req, HTTPServerResponse res)
				{
					enforceHTTP("username" in req.form &amp;&amp; "password" in req.form,
						HTTPStatus.badRequest, "Missing username/password field.");
				
					// todo: verify user/password here
				
					auto session = res.startSession();
					session.set("username", req.form["username"]);
					session.set("password", req.form["password"]);
					res.redirect("/home");
				}
				
				void logout(HTTPServerRequest req, HTTPServerResponse res)
				{
					if (res.session) res.terminateSession();
					res.redirect("/");
				}
				
				void checkLogin(HTTPServerRequest req, HTTPServerResponse res)
				{
					// force a redirect to / for unauthenticated users
					if (!req.session)
						res.redirect("/");
				}
				
				shared static this()
				{
					auto router = new URLRouter;
					router.get("/", staticTemplate!"index.dt");
					router.post("/login", &amp;login);
					router.post("/logout", &amp;logout);
					// restrict all following routes to authenticated users:
					router.any("*", &amp;checkLogin);
					router.get("/home", staticTemplate!"home.dt");
				
					auto settings = new HTTPServerSettings;
					settings.sessionStore = new MemorySessionStore;
					// ...
				}
			.caption Example: Using a HTTP session for user authentication


		section
			h3#http-client-requests Client requests
			
			p Client request are done using the <a href="api/vibe.http.client/requestHTTP"><code class="prettyprint">requestHTTP</code></a> function.

			pre.code.prettyprint.lang-d.
				import vibe.vibe;
				
				void main()
				{
					requestHTTP("http://google.com",
						(scope req) {
							// could add headers here before sending,
							// write a POST body, or do similar things.
						},
						(scope res) {
							logInfo("Response: %s", res.bodyReader.readAllUTF8());
						}
					);
				}
			.caption Example: Performing a simple HTTP request

			p A connection pool is used internally in conjunction with persistent HTTP connections (keep-alive) for maximum thoughput.


	section
		h2#web Web framework

		p Based on the low-level HTTP/HTML foundation, the high-level web application framework allows for faster and more solid web application development. It uses a class based declarative approach to avoid the boilerplate code that would otherwise usually be needed. Static typing is exploited as much as possible to avoid conversion errors, or errors accessing wrong runtime keys (such as a non-existent or mistyped form field).

		p The framework comes in two flavors, one for front end development, targeted at generating HTML pages and processing form requests, and one for REST based back end development, providing a transparent JSON/REST based RPC mechanism (client and server). Both of these components share the same basis and use the same approach to map class methods to routes of the <a href="api/vibe.http.router/URLRouter"><code>URLRouter</code></a>.

		p For the usual case, both, the HTTP method and the matching path are inferred from the class method's name. In particular, the name is mapped to a certain HTTP method according to its prefix and the rest of the name is converted to a path name in a <a href="api/vibe.web.common/MethodStyle">configurable style</a>. On top of that, it is possible to use the <a href="api/vibe.web.common/path"><code>@path</code></a> and <a href="api/vibe.web.common/method"><code>@method</code></a> attributes to override these defaults.

		table
			tr
				th HTTP method
				th Corresponding prefixes
			tr
				td GET
				td <code>get</code>, <code>query</code>, getter <code>@property</code> methods, methods named <code>index</code>
			tr
				td POST
				td <code>post</code>, <code>create</code>, <code>add</code>, no prefix
			tr
				td PUT
				td <code>put</code>, <code>set</code>, setter <code>@property</code> methods
			tr
				td PATCH
				td <code>patch</code>, <code>update</code>
			tr
				td DELETE
				td <code>delete</code>, <code>erase</code>, <code>remove</code>


		section
			h3#web-interface-generator Web interface generator

			p The front end web interface generator automatically maps incoming query or POST form fields to method parameters, performing the necessary conversion and validation automatically. On top of that, it offers several convenience functions for rendering Diet templates, handling sessions and performing redirects - without directly accessing the underlying <a href="api/vibe.http.server/HTTPServerRequest"><code class="typ">HTTPServerRequest</code></a> or <a href="api/vibe.http.server/HTTPServerResponse"><code class="typ">HTTPServerResponse</code></a> object. This enables a completely statically checked and clean code style in most cases.

			p For those situations where more control is required, it is possible to simply declare parameters of type <code class="typ">HTTPServerRequest</code> or <code class="typ">HTTPServerResponse</code> to give a method full access. Note that this is in contrast to the REST interface generator covered below, which cannot give access to the request/response without losing the ability to generate the client side of the REST protocol. It does, however, provide a way to get around this, using the <a href="api/vibe.web.rest/before"><code>@before</code></a> attribute.

			pre.code.prettyprint.lang-d.
				import vibe.http.router;
				import vibe.http.server;
				import vibe.web.web;

				shared static this()
				{
					auto router = new URLRouter;
					router.<a href="api/vibe.web.web/registerWebInterface">registerWebInterface</a>(new WebInterface);

					auto settings = new HTTPServerSettings;
					settings.port = 8080;
					settings.sessionStore = new MemorySessionStore;
					listenHTTP(settings, router);
				}

				class WebInterface {
					private {
						// stored in the session store
						<a href="api/vibe.web.web/SessionVar">SessionVar</a>!(bool, "authenticated") ms_authenticated;
					}

					// GET /
					void index()
					{
						bool authenticated = ms_authenticated;
						<a href="api/vibe.web.web/render">render</a>!("index.dt", authenticated);
					}

					// POST /login (username and password are automatically read as form fields)
					void postLogin(string username, string password)
					{
						enforceHTTP(username == "user" &amp;&amp; password == "secret",
							HTTPStatus.forbidden, "Invalid user name or password.");
						ms_authenticated = true;
						<a href="api/vibe.web.web/redirect">redirect</a>("/");
					}

					// POST /logout
					@method(HTTPMethod.POST) @path("logout")
					void postLogout()
					{
						ms_authenticated = false;
						<a href="api/vibe.web.web/terminateSession">terminateSession</a>();
						<a href="api/vibe.web.web/redirect">redirect</a>("/");
					}
				}
			.caption Example: source/app.d

			pre.code.lang-diet.
				doctype 5
				html
					head
						title Welcome
					body
						h1 Welcome

						- if (authenticated)
							form(action="logout", method="POST")
								button(type="submit") Log out
						- else
							h2 Log in
							form(action="login", method="POST")
								p User name:
									input(type="text", name="username")
								p Password:
									input(type="password", name="password")
								button(type="submit")
			.caption Example: views/index.dt

		section
			h3#web-localization Localization

			p Using <a href="http://www.gnu.org/software/gettext/">GNU gettext</a> compatible .po translation files, it's possible to localize Diet templates at compile time. This just requires putting the translation files with the naming scheme <code>&lt;name&gt;.&lt;language&gt;.po</code> into a path that is registered in the <code>"stringImportPaths"</code> field of the dub.json. <code>&lt;language&gt;</code> must be a language identifier of the form <code>en_US</code>.

			pre.code.prettyprint.lang-d.
				import vibe.web.web;

				struct TranslationContext {
					alias languages = TypeTuple!("en_US", "de_DE");
					mixin <a href="api/vibe.web.i18n/translationModule">translationModule</a>!"example";
				}

				<a href="api/vibe.web.i18n/translationContext">@translationContext</a>!TranslationContext
				class WebInterface {
					void index()
					{
						<a href="api/vibe.web.web/render">render</a>!("index.dt");
					}
				}
			.caption Example: source/app.d

			pre.code.lang-diet.
				doctype 5
				html
					head
						title& Welcome
					body
						h1& Welcome

						p& home.welcome.text
			.caption Example: views/index.dt

			pre.code.
				msgid "Welcome"
				msgstr "Welcome"

				msgid "home.welcome-text"
				msgstr "Hello, this is a translation example."
			.caption Example: translations/example.en_US.po

			pre.code.
				msgid "Welcome"
				msgstr "Willkommen"

				msgid "home.welcome-text"
				msgstr "Hallo, dies ist ein Übersetzungs-Beispiel."
			.caption Example: translations/example.de_DE.po


		section
			h3#rest-interface-generator REST interface generator

			p Similar to the browser oriented web interface generator, there is a machine communication oriented JSON/REST based interface generator. Method parameters are mapped to JSON fields and get serialized according to the usual <a href="api/vibe.data.serialization/">serialization rules</a>. In addition to the interface generator, there is also a client generator, which automatically implements a class that emits the proper REST calls to access the REST interface.

			pre.code.prettyprint.lang-d.
				import vibe.core.core;
				import vibe.core.log;
				import vibe.http.router;
				import vibe.http.server;
				import vibe.web.rest;

				struct Weather {
					string text;
					double temperature; // °C
				}

				interface MyAPI {
					// GET /weather -&gt; responds {"text": "...", "temperature": ...}
					Weather getWeather();

					// PUT /location -&gt; accepts {"location": "..."}
					@property void location(string location);

					// GET /location -&gt; responds "..."
					@property string location();
				}

				class MyAPIImplementation : MyAPI {
					private {
						string m_location;
					}

					Weather getWeather() { return Weather("sunny", 25); }

					@property void location(string location) { m_location = location; }
					@property string location() { return m_location; }
				}

				shared static this()
				{
					auto router = new URLRouter;
					router.<a href="api/vibe.web.rest/registerRestInterface">registerRestInterface</a>(new MyAPIImplementation);

					auto settings = new HTTPServerSettings;
					settings.port = 8080;
					listenHTTP(settings, router);

					// create a client to talk to the API implementation over the REST interface
					runTask({
						auto client = new <a href="api/vibe.web.rest/RestInterfaceClient">RestInterfaceClient</a>!MyAPI("http://127.0.0.1:8080/");
						auto weather = client.getWeather();
						logInfo("Weather: %s, %s °C", weather.text, weather.temperature);
						client.location = "Paris";
						logInfo("Location: %s", client.location);
					});
				}


	section
		h2#db-support Database support

		section
			h3#mongo MongoDB

			p A native
				a.extern(href="http://www.mongodb.org/", target="_blank") MongoDB
				| driver is part of the distribution supporting the standard set of database operations. Data is exchanged using the
				a(href="api/vibe.data.bson/Bson")
					code.prettyprint.lang-d Bson
				| struct.

			p For an comprehensive documentation of MongoDB's operations see the
				a.extern(href="http://www.mongodb.org/display/DOCS/Manual", target="_blank") MongoDB manual
				|. The
				a(href="api/vibe.db.mongo.mongo/connectMongoDB") API reference
				| contains the documentation for the driver.

			pre.code.prettyprint.lang-d.
				import vibe.d;
				
				MongoClient client;
				
				void test()
				{
					auto coll = client.getCollection("test.collection");
					foreach (doc; coll.find(["name": "Peter"]))
						logInfo("Found entry: %s", doc.toJson());
				}
				
				shared static this()
				{
					client = connectMongoDB("127.0.0.1");
				}
			.caption Example: Finding entries in a MongoDB

		section		
			h3#redis Redis
			
			p A client for the structured storage server
				a.extern(href="http://redis.io", target="_blank") Redis
				| is included in vibe.d. Commands and operations on Redis data types are implemented as instance methods of the <a href="api/vibe.db.redis.redis/RedisClient">client</a> and of the <a href="api/vibe.db.redis.redis/RedisDatabase"><code>RedisDatabase</code></a> class. The methods are named after their corresponding Redis command documented in the
				a.extern(href="http://redis.io/commands", target="_blank") command reference
				|.

			p On top of the low level interface, two high level modules, <a href="api/vibe.db.redis.types/"><code>types</code></a> and <a href="api/vibe.db.redis.idioms/"><code>idioms</code></a> are available to solve common tasks in a more convenient and type safe way. In addition to that, a <a href="api/vibe.db.redis.sessionstore/RedisSessionStore">Redis based HTTP session store</a> is also included.

	section
		h2#raw-tcp Raw TCP
		
		p Low level TCP connections are handled using the
			a(href="api/vibe.core.net/TCPConnection")
				code.prettyprint.lang-d TCPConnection
			| class, which implements the
			a(href="api/vibe.core.stream/ConnectionStream")
				code.prettyprint.lang-d ConnectionStream
			| interface. Connections can be established by either listening on a specific port for incoming connections or by actively connecting to a remote server.

		section
			h3#tcp-server Server
			
			p Listening for TCP connections is done using the
				a(href="api/vibe.core.net/listenTCP")
					code.prettyprint.lang-d listenTCP
				| function. An implementation of a very simple echo server could look like this:
				
			pre.code.prettyprint.lang-d.
				import vibe.d;
				
				shared static this()
				{
					listenTCP(7, (conn){ conn.write(conn) });
				}

			p Calling 
				a(href="api/vibe.core.net/listenTCP")
					code.prettyprint.lang-d listenTCP
				| like this will listen on all local network devices. To listen only on a specific device, the bind address can be given as an additional parameter:
			pre.code.prettyprint.lang-d.
				import vibe.d;
				
				shared static this()
				{
					listenTCP(7, conn =&gt; conn.write(conn), "127.0.0.1");
				}
				
			p The address can be given as either an IPv4 or an IPv6 address string.
				
		section
			h3#tcp-client Client
			
			p Connecting to a TCP server is done with the
				a(href="api/vibe.core.net/connectTCP")
					code.prettyprint.lang-d connectTCP
				| function. The following example gets the current time using the
				a.extern(href="http://en.wikipedia.org/wiki/Daytime_Protocol", target="_blank") Daytime Protocol
				|.
			pre.code.prettyprint.lang-d.
				import vibe.d;
				
				shared static this()
				{
					auto conn = connectTCP("time-c.nist.gov", 13);
					logInfo("The time is: %s", conn.readAllUTF8());
				}


	section
		h2#raw-udp Raw UDP
		
		p In addition to stream based TCP connections, packet based UDP communication is also supported. To open a UDP socket, use the
			a(href="api/vibe.core.net/listenUDP")
				code.prettyprint.lang-d listenUDP
			| function with the appropriate port. It will return a
			a(href="api/vibe.core.net/UDPConnection")
				code.prettyprint.lang-d UDPConnection
			| instance, which can then be used to send and receive individual packets.

		pre.code.prettyprint.lang-d.
			import vibe.appmain;
			import vibe.core.core;
			import vibe.core.log;
			import vibe.core.net;
			
			import core.time;
			
			
			shared static this()
			{
				runTask({
					auto udp_listener = listenUDP(1234);
					while (true) {
						auto pack = udp_listener.recv();
						logInfo("Got packet: %s", cast(string)pack);
					}
				});
				
				runTask({
					auto udp_sender = listenUDP(0);
					udp_sender.connect("127.0.0.1", 1234);
					while (true) {
						sleep(dur!"msecs"(500));
						logInfo("Sending packet...");
						udp_sender.send(cast(ubyte[])"Hello, World!");
					}
				});
			}
		.caption Example: Simple UDP based communication on localhost


	section
		h2#advanced Advanced topics
		
		section
			h3#dub-publishing Publishing on the DUB registry
			
			p The
				a.extern(href="http://code.dlang.org/", target="_blank") DUB registry
				| contains packages that use the same package management as vibe.d. Many of them extend and supplement vibe.d's functionality. The packages are automatically downloaded if the corresponding entry in the "dependencies" section of the project's dub.json file is present.
			
			p If you have written an extension library yourself, you can register it in the DUB registry so others can easily make use of it. For this to work, you will first have to write a proper dub.json, which has to reside in the root directory of your project (the project should adhere to the structure mentioned in the <a href="#first-steps">first steps</a>). The project currently also has to be hosted either on GitHub or on BitBucket. See <a href="http://code.dlang.org/publish">http://code.dlang.org/publish</a> for more information.
				
			pre.code.
				{
					"name": "vibelog",
					"description": "A light-weight embeddable blog implementation",
					"homepage": "https://github.com/rejectedsoftware/vibelog",
					"license": "AGPL-3.0",
					"authors": [
						"Sönke Ludwig"
					],
					"dependencies": {
						"vibe-d": "~&gt;0.7.23"
					}
				}
			.caption Example: A dub.json file suitable for registration as a DUB package.
				
			p You can then register your project on
				a.extern(href="http://code.dlang.org/", target="_blank") code.dlang.org
				| and as soon as you then add a new
				a.extern(href="http://learn.github.com/p/tagging.html", target="_blank") git tag
				| with the name matching the current version prefixed with "v" ("v0.0.1" for the example here), it should appear there. Note that the update can take up to 30 minutes. Anyone can then add an entry similar to the following to their project to make use of the library:
				
			pre.code.
				{
					...
					"dependencies": {
						"vibelog": "&gt;=0.0.1"
					}
				}
			.caption Example: Corresponding dependency to use the published DUB package.
		
		section
			h3#custom-main The main function
			
			p To simplify development of server-like applications that are command line based and run an event loop, vibe.d includes a default application entry point (<code>main()</code>). To use it, define the version <code>VibeDefaultMain</code> when building the project. This can be done by simply adding the following entry to your package description file: <code>"versions": ["VibeDefaultMain"]</code>

			p When writing a pure command line client application, maybe something like <a href="http://www.gnu.org/software/wget/">wget</a>, it may not be desirable to start an explicit event loop, but instead exit right after the work is done. Some applications might also need more control over how the application gets initialized and at which point the event loop is started. To support such usage scenarios, you can implement your own program entry function instead.

			p(style="color: red") Note: Projects that have their own program entry point currently, due to a transition process, also need to define a <code>VibeCustomMain</code> version instead of <code>VibeDefaultMain</code>. This requirement will be lifted in a later version of vibe.d.
				
			pre.code.prettyprint.lang-d.
				import vibe.vibe;
				
				void main()
				{
					// returns false if a help screen has been requested and displayed (--help)
					if (!finalizeCommandLineOptions())
						return;
					lowerPrivileges();
					runEventLoop();
				}
			.caption Example: Simple custom main function that runs an event loop.
			
			pre.code.prettyprint.lang-d.
				import vibe.vibe;
				
				void main()
				{
					auto f = openFile("test.html", FileMode.CreateTrunc);
					f.write(download("http://google.com/"));
				}
			.caption Example: Client application that downloads a document
		
		section
			h3#privilege-lowering Privilege lowering

			p For server applications it may be desirable to start the application as root so that it can listen on privileged ports or open system log files for writing. After these setup tasks, such applications impose a security risk because a hole in the application that allows to somehow execute malicious commands on the server will give the attacker full access to the system. For this reason vibe.d supports privilege lowering, where the user id and group id of the process are changed to an unprivileged user after the startup process, right before the event loop is started.
			
			p Privilege lowering can be configured in the configuration file /etc/vibe/vibe.conf (on Windows vibe.conf must be in the application's root directory instead). The two fields "user" and "group" have to be set to the the name or numeric ID of the unprivileged user/group.
			
			pre.code.
				{
					"user": "www-data",
					"group": "www-data"
				}
			.caption Example vibe.conf file

		section
			h3#compile-time-configuration Compile time configuration

			p There is a number of features that can be controlled via "versions". To defined a certain version, add the corresponding entry to the <code>"versions"</code> in your dub.json:
			pre.code.
				{
					...
					"versions": ["VibeManualMemoryManagement", "VibeDefaultMain"],
					...
				}
			.caption Declaring a "version" in dub.json

			table
				tr
					th Version constant
					th Meaning

				tr
					td
						code <s>VibeCustomMain</s>
					td <del>Tells vibe.d to not use its own predefined <code>main</code> function. This is mutually exclusive to <code>VibeDefaultMain</code>.</del> This is the default behavior since vibe.d 0.7.26.

				tr
					td
						code VibeDefaultMain
					td Tells vibe.d to use its own predefined <code>main</code> function. This is mutually exclusive to <code>VibeCustomMain</code>.

				tr
					td
						code VibeDisableCommandLineParsing
					td Disables automatic parsing of command line options passed to the application, such as "--help" or "--verbose".

				tr
					td
						code VibeNoDefaultArgs
					td Disables all default command line options, but keeps the command line argument module functional.

				tr
					td
						code VibeManualMemoryManagement
					td Performs a number of operations using manual memory management instead of the garbage collector, most notably in the HTTP server. This can lead to considerable performance improvements, but also makes certain operations unsafe and thus may open up the possibility for certain attacks. Especially any code needs to make sure to not escape any data (including <code>string</code> data) from <a href="api/vibe.http.server/HTTPServerRequest"><code>HTTPServerRequest</code></a>.

				tr
					td
						code VibeIdleCollect
					td Perform manual garbage collection runs when the application is idle for more than two seconds.

				tr
					td
						code VibePartialAutoExit
					td Partial workaround for issue <a href="https://github.com/rejectedsoftware/vibe.d/issues/212">#212</a> - exits the event loop after no mode file and socket based events exist. Note that this will exit the event loop, even if other kinds of events, such as timers, are still active. It is currently recommended to explicitly use <a href="api/vibe.core.core/exitEventLoop"><code>exitEventLoop</code></a> instead.

				tr
					td
						code VibeJsonFieldNames
					td Stores field names for JSON values for better error messages. This will use a few bytes of additional memory per <a href="api/vibe.data.json/Json"><code>Json</code></a> value.

				tr
					td
						code JsonLineNumbers
					td Stores line numbers for each JSON value parsed from a JSON string for improved error messages. This will store an additional <code>int</code> for each <a href="api/vibe.data.json/Json"><code>Json</code></a> value.

				tr
					td
						code VibeDebugCatchAll
					td Enables catching of exceptions that derive from <code>Error</code>. This can be useful during application development to get useful error information while keeping the application running, but can generally be dangerous, because the application may be left in a bad state after an <code>Error</code> has been thrown.

				tr
					td
						code VibeNoSSL
					td Does not use OpenSSL to provide TLS/SSL functionality. The <code>vibe.stream.ssl</code> module will be dysfunctional.

				tr
					td
						code VibeUseOldOpenSSL
					td Disables the use of features introduced in OpenSSL 1.0.1 or later, most notably ECDH curve selection. Use this to link against old versions of the OpenSSL library.

				tr
					td
						code VibePragmaLib
					td Uses a <code>pragma(lib)</code> to link against OpenSSL and libevent. This is only useful for building without DUB.

				tr
					td
						code VibeLibevDriver
					td Enables the libev based event driver (not fully functional). Do not use this version directly, but select the "libev" configuration in your dub.json instead.

				tr
					td
						code VibeLibeventDriver
					td Enables the libevent based event driver (currently the default). Do not use this version directly, but select the "libevent" configuration in your dub.json instead.

				tr
					td
						code VibeWin32Driver
					td Enables the Win32 based event driver (provides GUI message support on Windows). Do not use this version directly, but select the "win32" configuration in your dub.json instead.

				tr
					td
						code VibeWinrtDriver
					td Enables the WinRT based event driver (not yet implemented). Do not use this version directly, but select the "winrt" configuration in your dub.json instead.


		section
			h3#handling-segmentation-faults Handling segmentation-faults on Linux

			p While access violations on Windows usually trigger an exception with a convenient stack trace, on other operating systems D applications just terminate and possibly cause a core dump file to be written. However, there is a module hidden in the D runtime that enables such a stack trace also on Linux. Simply run the following code at program initialization:

			pre.code.prettyprint.lang-d.
				import etc.linux.memoryerror;
				static if (is(typeof(registerMemoryErrorHandler)))
					registerMemoryErrorHandler();

			This currently works only on Linux x86 and x86-64.
